'use strict';

const chalk = require('chalk');
const consola = require('consola');
const defu = require('defu');
const htmlValidate = require('html-validate');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

const chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
const consola__default = /*#__PURE__*/_interopDefaultLegacy(consola);
const defu__default = /*#__PURE__*/_interopDefaultLegacy(defu);

const defaultHtmlValidateConfig = {
  extends: [
    "html-validate:document",
    "html-validate:recommended",
    "html-validate:standard"
  ],
  rules: {
    "svg-focusable": "off",
    "no-unknown-elements": "error",
    "void-style": "off",
    "no-trailing-whitespace": "off",
    "require-sri": "off",
    "attribute-boolean-style": "off",
    "doctype-style": "off",
    "no-inline-style": "off"
  }
};
const DEFAULTS = {
  usePrettier: false,
  failOnError: false,
  options: defaultHtmlValidateConfig
};

const validators = new Map();
const defaultOptions = {};
const useValidator = (options = defaultOptions) => {
  if (validators.has(options)) {
    return { validator: validators.get(options) };
  }
  const validator = new htmlValidate.HtmlValidate(options);
  validators.set(options, validator);
  return { validator };
};
const useChecker = (validator, usePrettier = false, reporter = consola__default['default'].withTag("html-validate")) => {
  const invalidPages = [];
  const checkHTML = async (url, html) => {
    let couldFormat = false;
    try {
      if (usePrettier) {
        const { format } = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('prettier')); });
        html = format(html, { parser: "html" });
        couldFormat = true;
      }
    } catch (e) {
      reporter.error(e);
    }
    html = typeof html === "string" ? html.replace(/ ?data-v-[a-z0-9]+\b/g, "") : html;
    const { valid, results } = validator.validateString(html);
    if (valid) {
      return reporter.success(`No HTML validation errors found for ${chalk__default['default'].bold(url)}`);
    }
    invalidPages.push(url);
    const formatter = couldFormat ? htmlValidate.formatterFactory("codeframe") : htmlValidate.formatterFactory("stylish");
    const formattedResult = formatter(results);
    reporter.error([
      `HTML validation errors found for ${chalk__default['default'].bold(url)}`,
      formattedResult
    ].join("\n"));
  };
  return { checkHTML, invalidPages };
};

const CONFIG_KEY = "htmlValidator";
const nuxtModule = function(moduleOptions) {
  consola__default['default'].info(`Using ${chalk__default['default'].bold("html-validate")} to validate server-rendered HTML`);
  const providedOptions = defu__default['default'](this.options[CONFIG_KEY] || {}, moduleOptions);
  const { usePrettier, failOnError, options } = defu__default['default'](providedOptions, DEFAULTS);
  if (options && providedOptions.options && providedOptions.options.extends) {
    options.extends = providedOptions.options.extends;
  }
  const { validator } = useValidator(options);
  const { checkHTML, invalidPages } = useChecker(validator, usePrettier);
  this.nuxt.hook("render:route", (url, result) => checkHTML(url, result.html));
  this.nuxt.hook("generate:page", ({ path, html }) => checkHTML(path, html));
  this.nuxt.hook("generate:done", () => {
    if (failOnError && invalidPages.length) {
      throw new Error("html-validator found errors");
    }
  });
};
nuxtModule.meta = { name: "@nuxtjs/html-validator" };

module.exports = nuxtModule;
